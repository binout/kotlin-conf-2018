= Kotlin Conf

== DSL in Kotlin

https://kotlinconf.com/schedule/#session=40652

https://gitlab.com/asarazan/kotlinconf18

[quote]
When you really wish your language could do the thing

=== Ktor

image::http://ktor.io/what-is-ktor-shadow.png[]

=== Advices
[quote]
Start from the result that you want to enable +
... then write the code thant enables it !

`@DslMarker` : prevent scoping mishaps !

* Dont' pollute the global namespace
* Unary `+` only if well-scoped
* Keep lambda files next to your builder classes
* Don't extend system types (String, Int, ...)

[source, kotlin]
----
42 { //bad
.....
}

100.dollarsToCent() // Good
----

== Kotlin and Spring Boot, a match made in heaven

https://kotlinconf.com/schedule/#session=41106

@nicolas_frankel

ðŸ¤¯ The issue : MAGIC !

ðŸ§ The solution ? : functional configuration

Switch to reactive :

* JPA -> Mongo Reactive
* WebMVC -> WebFlux

Swith to static configuration (no magic) :

* RestController -> static route definitions -> Router definition DSL
* @Beans -> Bean Definition DSL
* `context.initializer.classes` property -> programmtically register BeansInitializer

=== SpringFu

https://spring.io/blog/2018/10/02/the-evolution-of-spring-fu

WARNING: Experimental ðŸ˜œ

https://github.com/ajavageek/springfunctional-migration

.kofu (no more annotations !)
[source, kotlin]
----
val beans = beans {
    bean<PersonHandler>()
    bean<PersonRepository>()
}

val app = application {
    import(beans)
    listener<ApplicationReadyEvent> {
        ref<PersonRepository>().insert(
                arrayListOf(Person(1, "John", "Doe", LocalDate.of(1970, 1, 1)),
                        Person(2, "Jane", "Doe", LocalDate.of(1970, 1, 1)),
                        Person(3, "Brian", "Goetz"))
        ).blockLast(Duration.ofSeconds(2))
    }
    server {
        import(::routes)
        codecs {
            jackson()
        }
    }
    mongodb {
        embedded()
    }
}

fun routes(handler: PersonHandler) = router {
    "/person".nest {
        GET("/{id}", handler::readOne)
        GET("/", handler::readAll)
    }
}

class PersonHandler(private val personRepository: PersonRepository) {
    fun readAll(request: ServerRequest) = ServerResponse.ok().body(personRepository.findAll())
    fun readOne(request: ServerRequest) = ServerResponse.ok().body(personRepository.findById(request.pathVariable("id").toLong()))
}

fun main(args: Array<String>) {
    app.run(args)
}

@Document
class Person(@Id val id: Long, val firstName: String, val lastName: String, val birthdate: LocalDate? = null)

class PersonRepository(private val mongo: ReactiveMongoOperations) {
    fun findAll() = mongo.findAll<Person>()
    fun findById(id: Long) = mongo.findById<Person>(id)
    fun insert(persons: List<Person>) = mongo.insert(persons, Person::class)
}
----